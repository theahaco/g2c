---
import BaseLayout from "../../layouts/BaseLayout.astro";
---

<BaseLayout title="Contract Account Wallet">
  <div class="page-header">
    <h1>Contract Account Wallet</h1>
    <a id="home-link" class="home-btn">Home</a>
  </div>

  <div id="error-box" class="error" style="display:none"></div>

  <!-- Signing mode UI -->
  <div id="signing-mode" class="hidden">
    <div class="signing-request">
      <h2>Signature Request</h2>
      <div>From: <span class="origin" id="sign-origin"></span></div>
      <div class="hash">Hash: <code id="sign-hash"></code></div>
    </div>

    <div id="sign-needs-register">
      <p class="info">No passkey registered yet. Register one first, then you can approve the request.</p>
      <div class="field">
        <button id="sign-register-btn">Register Passkey</button>
      </div>
    </div>

    <div id="sign-ready" class="hidden">
      <div class="field">
        <button id="approve-btn" class="primary">Approve & Sign</button>
        <button id="deny-btn" style="margin-left:0.5rem">Deny</button>
      </div>
    </div>

    <pre id="sign-mode-result" style="display:none"></pre>
  </div>

  <!-- Home mode UI -->
  <div id="home-mode" class="hidden">
    <section id="account-section">
      <h2>Account</h2>
      <div class="account-card">
        <div class="account-field">
          <span class="account-label">Address</span>
          <div class="address-row">
            <code id="contract-id" class="account-address"></code>
            <button id="copy-btn" class="copy-btn" title="Copy address">Copy</button>
          </div>
        </div>
        <div class="account-field">
          <span class="account-label">Balance</span>
          <span id="xlm-balance" class="balance-value">loading...</span>
        </div>
        <div class="account-links">
          <a id="explorer-link" class="explorer-link" target="_blank" rel="noopener" style="display:none">View on Stellar Expert</a>
        </div>
      </div>
    </section>

    <!-- Shown when a passkey is already registered -->
    <section id="passkey-info-section" class="hidden">
      <h2>Passkey</h2>
      <div class="passkey-details">
        <div class="passkey-status">Registered</div>
        <div class="passkey-field">
          <span class="passkey-label">Public Key</span>
          <code id="passkey-pubkey" class="passkey-value"></code>
        </div>
        <div class="passkey-field">
          <span class="passkey-label">Credential ID</span>
          <code id="passkey-cred-id" class="passkey-value"></code>
        </div>
        <div class="passkey-field">
          <span class="passkey-label">RP ID</span>
          <code id="passkey-rp-id" class="passkey-value"></code>
        </div>
        <p class="info rp-explainer">
          The RP ID (Relying Party Identifier) is the domain that your passkey is bound to.
          Each smart account gets its own subdomain, so passkeys are scoped per-account
          and cannot be used to authorize transactions on a different account.
        </p>
      </div>
    </section>

    <!-- Shown when no passkey is registered -->
    <section id="register-section" class="hidden">
      <h2>Register Passkey</h2>
      <p class="info">Creates a new passkey bound to this contract's subdomain.</p>
      <div class="field">
        <button id="register-btn">Register Passkey</button>
      </div>
      <pre id="no-key-register-result" style="display:none"></pre>
    </section>

    <section id="sign-section">
      <h2>Try It out</h2>
      <p class="info">Want to see how it works?
          Eventually, other stellar dApps will redirect to this domain when you need to sign a transaction.
          For now you can invoke a contract or sign arbitrary data below.
     </p>
      <h3>Invoke a contract</h3>
      <p class="info">Set a status message on-chain via your smart account.</p>
      <div class="field">
        <a id="status-message-link" class="button-link">Status Message</a>
      </div>
      <h3>Sign a Hash</h3>
      <p class="info">Authenticate with your passkey to sign a 32-byte hash (e.g. a transaction hash).</p>
      <div class="field">
        <label for="hash-input">Hash to sign (64 hex chars)</label>
        <input id="hash-input" placeholder="e.g. a1b2c3d...64 hex characters" maxlength="64" />
      </div>
      <div class="field" style="margin-top:0.5rem">
        <button id="sign-btn" disabled>Sign</button>
        <button id="random-hash-btn" style="margin-left:0.5rem; font-size:0.8rem">Random hash</button>
      </div>
      <pre id="sign-result" style="display:none"></pre>
    </section>
  </div>
</BaseLayout>

<style>
  body {
    background: #1a1a2e;
  }

  .page-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }


  button.primary {
    background: #1a6b3a;
    border-color: #1a8b4a;
    font-size: 1.1rem;
    padding: 0.7rem 2rem;
  }

  button.primary:hover {
    background: #1a8b4a;
  }

  .account-card {
    background: #0a2040;
    border: 1px solid #1a3060;
    border-radius: 6px;
    padding: 1rem;
  }

  .account-field {
    margin-bottom: 0.75rem;
  }

  .account-field:last-of-type {
    margin-bottom: 0;
  }

  .account-label {
    color: #8899aa;
    display: block;
    font-size: 0.8rem;
    margin-bottom: 0.25rem;
  }

  .address-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .account-address {
    color: #c0d0e0;
    word-break: break-all;
    font-size: 0.85rem;
  }

  .copy-btn {
    background: #1a3060;
    color: #8899aa;
    border: 1px solid #2a4070;
    padding: 0.2rem 0.5rem;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.75rem;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .copy-btn:hover {
    background: #2a4070;
    color: #c0d0e0;
  }

  .balance-value {
    font-family: monospace;
    font-size: 1.3rem;
    color: #e0e0e0;
  }

  .account-links {
    margin-top: 0.75rem;
  }

  .explorer-link {
    color: #5bc0de;
    text-decoration: underline;
    font-size: 0.8rem;
  }

  .explorer-link:hover {
    color: #7dd4ed;
  }

  .signing-request {
    background: #1a2a1a;
    border: 1px solid #2a4a2a;
    border-radius: 6px;
    padding: 1rem;
    margin: 1rem 0;
  }

  .signing-request .origin {
    color: #80b0e0;
    font-size: 0.9rem;
  }

  .signing-request .hash {
    font-family: monospace;
    font-size: 0.8rem;
    color: #c0c0c0;
    margin: 0.75rem 0;
    word-break: break-all;
  }

  .passkey-details {
    background: #0a2040;
    border: 1px solid #1a3060;
    border-radius: 6px;
    padding: 0.75rem 1rem;
  }

  .passkey-status {
    color: #6fcf97;
    font-weight: 600;
    margin-bottom: 0.5rem;
  }

  .passkey-field {
    margin: 0.4rem 0;
    font-size: 0.85rem;
  }

  .passkey-label {
    color: #8899aa;
    display: block;
    margin-bottom: 0.15rem;
  }

  .passkey-value {
    color: #c0d0e0;
    word-break: break-all;
    font-size: 0.8rem;
  }

  .rp-explainer {
    margin-top: 0.75rem;
    margin-bottom: 0;
    font-size: 0.8rem;
  }

  .button-link {
    display: inline-block;
    background: #4a1a6b;
    color: #e0e0e0;
    border: 1px solid #6a2a8b;
    padding: 0.5rem 1.2rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.95rem;
    text-decoration: none;
  }

  .button-link:hover {
    background: #5a2a7b;
  }
</style>

<script>
  import {
    Asset,
    Networks,
    Address,
    Contract,
    TransactionBuilder,
    Account,
    rpc,
    scValToNative,
  } from "@stellar/stellar-sdk";
  import {
    parseRegistration,
    derToCompact,
    buf2hex,
    hex2buf,
    buf2base64url,
    contractIdFromHostname,
    stripSubdomain,
    saveCredential as sdkSaveCredential,
    loadCredential as sdkLoadCredential,
  } from "@g2c/passkey-sdk";
  import { formatSignResult } from "../../lib/formatting";

  const RPC_URL = "https://soroban-testnet.stellar.org";

  // --- State ---

  const hostname = window.location.hostname;
  const contractId = contractIdFromHostname(hostname);
  const rpId = hostname;

  const params = new URLSearchParams(window.location.search);
  const signHashParam = params.get("sign");
  const callbackUrl = params.get("callback");
  const isSigningMode = signHashParam && callbackUrl;

  function saveCredential(credentialId: Uint8Array, publicKey: Uint8Array) {
    sdkSaveCredential(contractId!, credentialId, publicKey);
  }

  function loadCredential() {
    return contractId ? sdkLoadCredential(contractId) : null;
  }

  // --- Shared: register passkey ---

  async function registerPasskey() {
    if (!contractId) throw new Error("Navigate to <contractId>.<domain> to use");

    const userId = new Uint8Array(16);
    crypto.getRandomValues(userId);

    const credential = (await navigator.credentials.create({
      publicKey: {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        rp: { name: `Soroban ${contractId}`, id: rpId },
        user: {
          id: userId,
          name: contractId,
          displayName: `Account ${contractId}`,
        },
        pubKeyCredParams: [{ alg: -7, type: "public-key" }],
        authenticatorSelection: {
          residentKey: "required",
          userVerification: "required",
        },
        attestation: "none",
        timeout: 60000,
      },
    })) as PublicKeyCredential;

    const reg = parseRegistration(credential as any);
    saveCredential(reg.credentialId, reg.publicKey);
    return reg;
  }

  // --- Shared: sign hash ---

  async function signHash(hashHex: string) {
    const cred = loadCredential();
    if (!cred) throw new Error("No passkey registered");

    const challenge = hex2buf(hashHex);

    const assertion = (await navigator.credentials.get({
      publicKey: {
        challenge: challenge,
        rpId: rpId,
        allowCredentials: [
          {
            id: cred.credentialId,
            type: "public-key",
          },
        ],
        userVerification: "required",
        timeout: 60000,
      },
    })) as PublicKeyCredential;

    const response = assertion.response as AuthenticatorAssertionResponse;
    const authenticatorData = new Uint8Array(response.authenticatorData);
    const clientDataJSON = new Uint8Array(response.clientDataJSON);
    const signatureDer = new Uint8Array(response.signature);
    const signatureCompact = derToCompact(signatureDer);

    return {
      authenticatorData: buf2hex(authenticatorData),
      clientDataJSON: buf2hex(clientDataJSON),
      signature: buf2hex(signatureCompact),
      publicKey: cred.publicKey,
    };
  }

  // --- UI helpers ---

  function showError(msg: string) {
    const $errorBox = document.getElementById("error-box")!;
    $errorBox.textContent = msg;
    $errorBox.style.display = "block";
  }

  function clearError() {
    document.getElementById("error-box")!.style.display = "none";
  }

  function initAccountCard() {
    document.getElementById("contract-id")!.textContent =
      contractId || "(unknown)";

    const $explorerLink = document.getElementById("explorer-link") as HTMLAnchorElement;
    if (contractId) {
      $explorerLink.href = `https://stellar.expert/explorer/testnet/contract/${contractId}`;
      $explorerLink.style.display = "inline";
    }

    // Copy button
    document.getElementById("copy-btn")!.addEventListener("click", async () => {
      if (!contractId) return;
      const btn = document.getElementById("copy-btn") as HTMLButtonElement;
      try {
        await navigator.clipboard.writeText(contractId);
        btn.textContent = "Copied!";
        setTimeout(() => { btn.textContent = "Copy"; }, 1500);
      } catch {
        btn.textContent = "Failed";
        setTimeout(() => { btn.textContent = "Copy"; }, 1500);
      }
    });
  }

  // =====================
  // SIGNING MODE
  // =====================

  function initSigningMode() {
    document.getElementById("signing-mode")!.classList.remove("hidden");

    // Show request details
    let originDisplay: string;
    try {
      originDisplay = new URL(callbackUrl!).origin;
    } catch {
      originDisplay = callbackUrl!;
    }
    document.getElementById("sign-origin")!.textContent = originDisplay;
    document.getElementById("sign-hash")!.textContent = signHashParam;

    const cred = loadCredential();
    if (cred) {
      document.getElementById("sign-ready")!.classList.remove("hidden");
      document.getElementById("sign-needs-register")!.classList.add("hidden");
    } else {
      document.getElementById("sign-needs-register")!.classList.remove("hidden");
      document.getElementById("sign-ready")!.classList.add("hidden");
    }

    // Register button in signing mode
    document.getElementById("sign-register-btn")!.addEventListener("click", async () => {
      clearError();
      const btn = document.getElementById("sign-register-btn") as HTMLButtonElement;
      try {
        btn.disabled = true;
        btn.textContent = "Waiting for authenticator...";
        await registerPasskey();
        document.getElementById("sign-needs-register")!.classList.add("hidden");
        document.getElementById("sign-ready")!.classList.remove("hidden");
      } catch (err: any) {
        showError(`Registration failed: ${err.message}`);
      } finally {
        btn.disabled = false;
        btn.textContent = "Register Passkey";
      }
    });

    // Approve button
    document.getElementById("approve-btn")!.addEventListener("click", async () => {
      clearError();

      const btn = document.getElementById("approve-btn") as HTMLButtonElement;
      try {
        btn.disabled = true;
        btn.textContent = "Waiting for authenticator...";

        const result = await signHash(signHashParam!);

        const $result = document.getElementById("sign-mode-result")!;
        $result.style.display = "block";
        $result.textContent = "Signed! Redirecting...";

        const cbUrl = new URL(callbackUrl!);
        cbUrl.searchParams.set("authenticatorData", result.authenticatorData);
        cbUrl.searchParams.set("clientDataJSON", result.clientDataJSON);
        cbUrl.searchParams.set("signature", result.signature);
        cbUrl.searchParams.set("publicKey", result.publicKey);

        setTimeout(() => {
          window.location.href = cbUrl.toString();
        }, 500);
      } catch (err: any) {
        showError(`Signing failed: ${err.message}`);
        btn.disabled = false;
        btn.textContent = "Approve & Sign";
      }
    });

    // Deny button
    document.getElementById("deny-btn")!.addEventListener("click", () => {
      try {
        const cbUrl = new URL(callbackUrl!);
        cbUrl.searchParams.set("error", "denied");
        window.location.href = cbUrl.toString();
      } catch {
        window.history.back();
      }
    });
  }

  // =====================
  // HOME MODE
  // =====================

  function showPasskeyInfo(cred: { credentialId: Uint8Array; publicKey: string }) {
    document.getElementById("passkey-info-section")!.classList.remove("hidden");
    document.getElementById("register-section")!.classList.add("hidden");
    document.getElementById("passkey-pubkey")!.textContent = cred.publicKey;
    document.getElementById("passkey-cred-id")!.textContent = buf2base64url(cred.credentialId);
    document.getElementById("passkey-rp-id")!.textContent = rpId;
  }

  function initHomeMode() {
    document.getElementById("home-mode")!.classList.remove("hidden");

    const $signBtn = document.getElementById("sign-btn") as HTMLButtonElement;
    const $signResult = document.getElementById("sign-result") as HTMLPreElement;
    const $hashInput = document.getElementById("hash-input") as HTMLInputElement;
    const $randomHashBtn = document.getElementById("random-hash-btn") as HTMLButtonElement;

    const cred = loadCredential();
    if (cred) {
      showPasskeyInfo(cred);
      $signBtn.disabled = false;
    } else {
      document.getElementById("register-section")!.classList.remove("hidden");
    }

    // Register passkey (when none exists yet)
    const $registerBtn = document.getElementById("register-btn") as HTMLButtonElement;
    const $noKeyRegisterResult = document.getElementById("no-key-register-result") as HTMLPreElement;
    $registerBtn.addEventListener("click", async () => {
      clearError();
      try {
        $registerBtn.disabled = true;
        $registerBtn.textContent = "Waiting for authenticator...";

        const { credentialId, publicKey } = await registerPasskey();

        $noKeyRegisterResult.style.display = "block";
        $noKeyRegisterResult.textContent = JSON.stringify(
          {
            credentialId: buf2base64url(credentialId),
            publicKey: buf2hex(publicKey),
            rpId: rpId,
          },
          null,
          2
        );

        $signBtn.disabled = false;

        const newCred = loadCredential();
        if (newCred) showPasskeyInfo(newCred);
      } catch (err: any) {
        showError(`Registration failed: ${err.message}`);
      } finally {
        $registerBtn.disabled = false;
        $registerBtn.textContent = "Register Passkey";
      }
    });

    // Sign
    $signBtn.addEventListener("click", async () => {
      clearError();
      const hashHex = $hashInput.value.trim();
      if (!/^[0-9a-fA-F]{64}$/.test(hashHex)) {
        showError("Enter a valid 32-byte hash (64 hex characters)");
        return;
      }

      try {
        $signBtn.disabled = true;
        $signBtn.textContent = "Waiting for authenticator...";

        const result = await signHash(hashHex);

        $signResult.style.display = "block";
        $signResult.innerHTML = formatSignResult(result);
      } catch (err: any) {
        showError(`Signing failed: ${err.message}`);
      } finally {
        $signBtn.disabled = false;
        $signBtn.textContent = "Sign";
      }
    });

    // Random hash
    $randomHashBtn.addEventListener("click", () => {
      const bytes = crypto.getRandomValues(new Uint8Array(32));
      $hashInput.value = buf2hex(bytes);
    });
  }

  // --- Balance ---

  async function fetchXlmBalance(contractAddress: string): Promise<string> {
    const server = new rpc.Server(RPC_URL);
    const xlmSacId = Asset.native().contractId(Networks.TESTNET);
    const xlmContract = new Contract(xlmSacId);

    const dummySource = new Account(
      "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF",
      "0"
    );

    const tx = new TransactionBuilder(dummySource, {
      fee: "100",
      networkPassphrase: Networks.TESTNET,
    })
      .addOperation(
        xlmContract.call("balance", Address.fromString(contractAddress).toScVal())
      )
      .setTimeout(0)
      .build();

    const sim = await server.simulateTransaction(tx);
    if (rpc.Api.isSimulationError(sim)) return "0";

    const successSim = sim as rpc.Api.SimulateTransactionSuccessResponse;
    if (!successSim.result) return "0";

    const rawBalance = scValToNative(successSim.result.retval) as bigint;
    const xlm = Number(rawBalance) / 10_000_000;
    return xlm.toFixed(7);
  }

  // --- Init ---

  initAccountCard();

  // Set navigation links
  if (contractId) {
    const rootHost = stripSubdomain(window.location.host);
    const $statusMessageLink = document.getElementById("status-message-link") as HTMLAnchorElement;
    $statusMessageLink.href = `//${rootHost}/status-message/?contract=${contractId}`;
    const $homeLink = document.getElementById("home-link") as HTMLAnchorElement;
    $homeLink.href = `//${rootHost}/`;
  }

  if (isSigningMode) {
    initSigningMode();
  } else {
    initHomeMode();
  }

  // Fetch balance in background
  if (contractId) {
    fetchXlmBalance(contractId).then((balance) => {
      document.getElementById("xlm-balance")!.textContent = `${balance} XLM`;
    }).catch(() => {
      document.getElementById("xlm-balance")!.textContent = "unavailable";
    });
  } else {
    document.getElementById("xlm-balance")!.textContent = "â€”";
  }
</script>
