---
import BaseLayout from "../../layouts/BaseLayout.astro";
---

<BaseLayout title="Soroban Passkey Account">
  <h1>Soroban Passkey</h1>
  <div id="status-bar">
    <div>Contract: <code id="contract-id"></code> <a id="explorer-link" class="explorer-link" target="_blank" rel="noopener" style="display:none">View on Stellar Expert</a></div>
    <div>RP ID: <code id="rp-id"></code></div>
    <div>Stored key: <code id="stored-key">none</code></div>
  </div>

  <div id="error-box" class="error" style="display:none"></div>

  <!-- Signing mode UI -->
  <div id="signing-mode" class="hidden">
    <div class="signing-request">
      <h2>Signature Request</h2>
      <div>From: <span class="origin" id="sign-origin"></span></div>
      <div class="hash">Hash: <code id="sign-hash"></code></div>
    </div>

    <div id="sign-needs-register">
      <p class="info">No passkey registered yet. Register one first, then you can approve the request.</p>
      <div class="field">
        <button id="sign-register-btn">Register Passkey</button>
      </div>
    </div>

    <div id="sign-ready" class="hidden">
      <div class="field">
        <button id="approve-btn" class="primary">Approve & Sign</button>
        <button id="deny-btn" style="margin-left:0.5rem">Deny</button>
      </div>
    </div>

    <pre id="sign-mode-result" style="display:none"></pre>
  </div>

  <!-- Home mode UI -->
  <div id="home-mode" class="hidden">
    <!-- Shown when a passkey is already registered -->
    <section id="passkey-info-section" class="hidden">
      <h2>Passkey</h2>
      <div class="passkey-details">
        <div class="passkey-status">Registered</div>
        <div class="passkey-field">
          <span class="passkey-label">Public Key</span>
          <code id="passkey-pubkey" class="passkey-value"></code>
        </div>
        <div class="passkey-field">
          <span class="passkey-label">Credential ID</span>
          <code id="passkey-cred-id" class="passkey-value"></code>
        </div>
      </div>
      <details style="margin-top:0.75rem">
        <summary class="reregister-summary">Re-register Passkey</summary>
        <p class="info" style="margin-top:0.5rem">Replace the locally stored passkey credential. Note: this does not change the on-chain signer.</p>
        <div class="field">
          <button id="reregister-btn">Re-register</button>
        </div>
      </details>
      <pre id="register-result" style="display:none"></pre>
    </section>

    <!-- Shown when no passkey is registered -->
    <section id="register-section" class="hidden">
      <h2>Register Passkey</h2>
      <p class="info">Creates a new passkey bound to this contract's subdomain.</p>
      <div class="field">
        <button id="register-btn">Register Passkey</button>
      </div>
      <pre id="no-key-register-result" style="display:none"></pre>
    </section>

    <section id="dapp-section">
      <h2>Try dApp</h2>
      <p class="info">Test a signature request flow with the demo dApp.</p>
      <div class="field">
        <a id="dapp-link" class="button-link">Open Demo dApp</a>
        <a id="status-message-link" class="button-link" style="margin-left:0.5rem">Status Message</a>
      </div>
    </section>

    <section id="sign-section">
      <h2>Sign a Hash</h2>
      <p class="info">Authenticate with your passkey to sign a 32-byte hash (e.g. a transaction hash).</p>
      <div class="field">
        <label for="hash-input">Hash to sign (64 hex chars)</label>
        <input id="hash-input" placeholder="e.g. a1b2c3d...64 hex characters" maxlength="64" />
      </div>
      <div class="field" style="margin-top:0.5rem">
        <button id="sign-btn" disabled>Sign</button>
        <button id="random-hash-btn" style="margin-left:0.5rem; font-size:0.8rem">Random hash</button>
      </div>
      <pre id="sign-result" style="display:none"></pre>
    </section>
  </div>
</BaseLayout>

<style>
  body {
    background: #1a1a2e;
  }

  button.primary {
    background: #1a6b3a;
    border-color: #1a8b4a;
    font-size: 1.1rem;
    padding: 0.7rem 2rem;
  }

  button.primary:hover {
    background: #1a8b4a;
  }

  #status-bar {
    background: #0a2040;
    border: 1px solid #1a3060;
    border-radius: 4px;
    padding: 0.5rem 0.75rem;
    margin: 1rem 0;
    font-size: 0.85rem;
  }

  .signing-request {
    background: #1a2a1a;
    border: 1px solid #2a4a2a;
    border-radius: 6px;
    padding: 1rem;
    margin: 1rem 0;
  }

  .signing-request h2 {
    margin-top: 0;
    color: #90d090;
  }

  .signing-request .origin {
    color: #80b0e0;
    font-size: 0.9rem;
  }

  .signing-request .hash {
    font-family: monospace;
    font-size: 0.8rem;
    color: #c0c0c0;
    margin: 0.75rem 0;
    word-break: break-all;
  }

  .passkey-details {
    background: #0a2040;
    border: 1px solid #1a3060;
    border-radius: 6px;
    padding: 0.75rem 1rem;
  }

  .passkey-status {
    color: #6fcf97;
    font-weight: 600;
    margin-bottom: 0.5rem;
  }

  .passkey-field {
    margin: 0.4rem 0;
    font-size: 0.85rem;
  }

  .passkey-label {
    color: #8899aa;
    display: block;
    margin-bottom: 0.15rem;
  }

  .passkey-value {
    color: #c0d0e0;
    word-break: break-all;
    font-size: 0.8rem;
  }

  .reregister-summary {
    color: #8899aa;
    cursor: pointer;
    font-size: 0.85rem;
  }

  .reregister-summary:hover {
    color: #c0d0e0;
  }

  .explorer-link {
    color: #5bc0de;
    text-decoration: underline;
    font-size: 0.8rem;
    margin-left: 0.5rem;
  }

  .explorer-link:hover {
    color: #7dd4ed;
  }

  .button-link {
    display: inline-block;
    background: #4a1a6b;
    color: #e0e0e0;
    border: 1px solid #6a2a8b;
    padding: 0.5rem 1.2rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.95rem;
    text-decoration: none;
  }

  .button-link:hover {
    background: #5a2a7b;
  }
</style>

<script>
  import {
    extractPublicKey,
    derToCompact,
    buf2hex,
    hex2buf,
    buf2base64url,
    contractIdFromHostname,
    stripSubdomain,
    saveCredential as sdkSaveCredential,
    loadCredential as sdkLoadCredential,
  } from "@g2c/passkey-sdk";
  import { formatSignResult } from "../../lib/formatting";

  // --- State ---

  const hostname = window.location.hostname;
  const contractId = contractIdFromHostname(hostname);
  const rpId = hostname;

  const params = new URLSearchParams(window.location.search);
  const signHashParam = params.get("sign");
  const callbackUrl = params.get("callback");
  const isSigningMode = signHashParam && callbackUrl;

  function saveCredential(credentialId: Uint8Array, publicKey: Uint8Array) {
    sdkSaveCredential(contractId!, credentialId, publicKey);
  }

  function loadCredential() {
    return contractId ? sdkLoadCredential(contractId) : null;
  }

  // --- Shared: register passkey ---

  async function registerPasskey() {
    if (!contractId) throw new Error("Navigate to <contractId>.<domain> to use");

    const userId = new Uint8Array(16);
    crypto.getRandomValues(userId);

    const credential = (await navigator.credentials.create({
      publicKey: {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        rp: { name: `Soroban ${contractId.slice(0, 8)}...`, id: rpId },
        user: {
          id: userId,
          name: contractId,
          displayName: `Account ${contractId.slice(0, 8)}...${contractId.slice(-4)}`,
        },
        pubKeyCredParams: [{ alg: -7, type: "public-key" }],
        authenticatorSelection: {
          residentKey: "required",
          userVerification: "required",
        },
        attestation: "none",
        timeout: 60000,
      },
    })) as PublicKeyCredential;

    const response = credential.response as AuthenticatorAttestationResponse;
    const publicKey = extractPublicKey(response);
    const credentialId = new Uint8Array(credential.rawId);
    saveCredential(credentialId, publicKey);
    return { credentialId, publicKey };
  }

  // --- Shared: sign hash ---

  async function signHash(hashHex: string) {
    const cred = loadCredential();
    if (!cred) throw new Error("No passkey registered");

    const challenge = hex2buf(hashHex);

    const assertion = (await navigator.credentials.get({
      publicKey: {
        challenge: challenge,
        rpId: rpId,
        allowCredentials: [
          {
            id: cred.credentialId,
            type: "public-key",
          },
        ],
        userVerification: "required",
        timeout: 60000,
      },
    })) as PublicKeyCredential;

    const response = assertion.response as AuthenticatorAssertionResponse;
    const authenticatorData = new Uint8Array(response.authenticatorData);
    const clientDataJSON = new Uint8Array(response.clientDataJSON);
    const signatureDer = new Uint8Array(response.signature);
    const signatureCompact = derToCompact(signatureDer);

    return {
      authenticatorData: buf2hex(authenticatorData),
      clientDataJSON: buf2hex(clientDataJSON),
      signature: buf2hex(signatureCompact),
      publicKey: cred.publicKey,
    };
  }

  // --- UI helpers ---

  function showError(msg: string) {
    const $errorBox = document.getElementById("error-box")!;
    $errorBox.textContent = msg;
    $errorBox.style.display = "block";
  }

  function clearError() {
    document.getElementById("error-box")!.style.display = "none";
  }

  function updateStatusBar() {
    document.getElementById("contract-id")!.textContent =
      contractId || "(visit via <contractId>.<domain>)";
    document.getElementById("rp-id")!.textContent = rpId;

    const $explorerLink = document.getElementById("explorer-link") as HTMLAnchorElement;
    if (contractId) {
      $explorerLink.href = `https://stellar.expert/explorer/testnet/contract/${contractId}`;
      $explorerLink.style.display = "inline";
    }

    const cred = loadCredential();
    document.getElementById("stored-key")!.textContent = cred ? cred.publicKey : "none";
    return cred;
  }

  // =====================
  // SIGNING MODE
  // =====================

  function initSigningMode() {
    document.getElementById("signing-mode")!.classList.remove("hidden");

    // Show request details
    let originDisplay: string;
    try {
      originDisplay = new URL(callbackUrl!).origin;
    } catch {
      originDisplay = callbackUrl!;
    }
    document.getElementById("sign-origin")!.textContent = originDisplay;
    document.getElementById("sign-hash")!.textContent = signHashParam;

    const cred = loadCredential();
    if (cred) {
      document.getElementById("sign-ready")!.classList.remove("hidden");
      document.getElementById("sign-needs-register")!.classList.add("hidden");
    } else {
      document.getElementById("sign-needs-register")!.classList.remove("hidden");
      document.getElementById("sign-ready")!.classList.add("hidden");
    }

    // Register button in signing mode
    document.getElementById("sign-register-btn")!.addEventListener("click", async () => {
      clearError();
      const btn = document.getElementById("sign-register-btn") as HTMLButtonElement;
      try {
        btn.disabled = true;
        btn.textContent = "Waiting for authenticator...";
        await registerPasskey();
        updateStatusBar();
        document.getElementById("sign-needs-register")!.classList.add("hidden");
        document.getElementById("sign-ready")!.classList.remove("hidden");
      } catch (err: any) {
        showError(`Registration failed: ${err.message}`);
      } finally {
        btn.disabled = false;
        btn.textContent = "Register Passkey";
      }
    });

    // Approve button
    document.getElementById("approve-btn")!.addEventListener("click", async () => {
      clearError();
      // if (!/^[0-9a-fA-F]{64}$/.test(signHashParam!)) {
      //   showError("Invalid hash in sign parameter (need 64 hex chars)");
      //   return;
      // }

      const btn = document.getElementById("approve-btn") as HTMLButtonElement;
      try {
        btn.disabled = true;
        btn.textContent = "Waiting for authenticator...";

        const result = await signHash(signHashParam!);

        const $result = document.getElementById("sign-mode-result")!;
        $result.style.display = "block";
        $result.textContent = "Signed! Redirecting...";

        const cbUrl = new URL(callbackUrl!);
        cbUrl.searchParams.set("authenticatorData", result.authenticatorData);
        cbUrl.searchParams.set("clientDataJSON", result.clientDataJSON);
        cbUrl.searchParams.set("signature", result.signature);
        cbUrl.searchParams.set("publicKey", result.publicKey);

        setTimeout(() => {
          window.location.href = cbUrl.toString();
        }, 500);
      } catch (err: any) {
        showError(`Signing failed: ${err.message}`);
        btn.disabled = false;
        btn.textContent = "Approve & Sign";
      }
    });

    // Deny button
    document.getElementById("deny-btn")!.addEventListener("click", () => {
      try {
        const cbUrl = new URL(callbackUrl!);
        cbUrl.searchParams.set("error", "denied");
        window.location.href = cbUrl.toString();
      } catch {
        window.history.back();
      }
    });
  }

  // =====================
  // HOME MODE
  // =====================

  function showPasskeyInfo(cred: { credentialId: Uint8Array; publicKey: string }) {
    document.getElementById("passkey-info-section")!.classList.remove("hidden");
    document.getElementById("register-section")!.classList.add("hidden");
    document.getElementById("passkey-pubkey")!.textContent = cred.publicKey;
    document.getElementById("passkey-cred-id")!.textContent = buf2base64url(cred.credentialId);
  }

  function initHomeMode() {
    document.getElementById("home-mode")!.classList.remove("hidden");

    const $signBtn = document.getElementById("sign-btn") as HTMLButtonElement;
    const $signResult = document.getElementById("sign-result") as HTMLPreElement;
    const $hashInput = document.getElementById("hash-input") as HTMLInputElement;
    const $randomHashBtn = document.getElementById("random-hash-btn") as HTMLButtonElement;

    const cred = loadCredential();
    if (cred) {
      showPasskeyInfo(cred);
      $signBtn.disabled = false;
    } else {
      document.getElementById("register-section")!.classList.remove("hidden");
    }

    // Re-register (when passkey already exists)
    async function handleRegister(btn: HTMLButtonElement, resultEl: HTMLPreElement) {
      clearError();
      try {
        btn.disabled = true;
        btn.textContent = "Waiting for authenticator...";

        const { credentialId, publicKey } = await registerPasskey();

        resultEl.style.display = "block";
        resultEl.textContent = JSON.stringify(
          {
            credentialId: buf2base64url(credentialId),
            publicKey: buf2hex(publicKey),
            rpId: rpId,
          },
          null,
          2
        );

        updateStatusBar();
        $signBtn.disabled = false;

        // Switch to info view
        const newCred = loadCredential();
        if (newCred) showPasskeyInfo(newCred);
      } catch (err: any) {
        showError(`Registration failed: ${err.message}`);
      } finally {
        btn.disabled = false;
        btn.textContent = btn.id === "reregister-btn" ? "Re-register" : "Register Passkey";
      }
    }

    const $reregisterBtn = document.getElementById("reregister-btn") as HTMLButtonElement;
    const $registerResult = document.getElementById("register-result") as HTMLPreElement;
    $reregisterBtn.addEventListener("click", () => handleRegister($reregisterBtn, $registerResult));

    const $registerBtn = document.getElementById("register-btn") as HTMLButtonElement;
    const $noKeyRegisterResult = document.getElementById("no-key-register-result") as HTMLPreElement;
    $registerBtn.addEventListener("click", () => handleRegister($registerBtn, $noKeyRegisterResult));

    // Sign
    $signBtn.addEventListener("click", async () => {
      clearError();
      const hashHex = $hashInput.value.trim();
      if (!/^[0-9a-fA-F]{64}$/.test(hashHex)) {
        showError("Enter a valid 32-byte hash (64 hex characters)");
        return;
      }

      try {
        $signBtn.disabled = true;
        $signBtn.textContent = "Waiting for authenticator...";

        const result = await signHash(hashHex);

        $signResult.style.display = "block";
        $signResult.innerHTML = formatSignResult(result);
      } catch (err: any) {
        showError(`Signing failed: ${err.message}`);
      } finally {
        $signBtn.disabled = false;
        $signBtn.textContent = "Sign";
      }
    });

    // Random hash
    $randomHashBtn.addEventListener("click", () => {
      const bytes = crypto.getRandomValues(new Uint8Array(32));
      $hashInput.value = buf2hex(bytes);
    });
  }

  // --- Init ---

  updateStatusBar();

  // Set dApp links
  if (contractId) {
    const rootHost = stripSubdomain(window.location.host);
    const $dappLink = document.getElementById("dapp-link") as HTMLAnchorElement;
    $dappLink.href = `//${rootHost}/dapp/?contract=${contractId}`;
    const $statusMessageLink = document.getElementById("status-message-link") as HTMLAnchorElement;
    $statusMessageLink.href = `//${rootHost}/status-message/?contract=${contractId}`;
  }

  if (isSigningMode) {
    initSigningMode();
  } else {
    initHomeMode();
  }
</script>
